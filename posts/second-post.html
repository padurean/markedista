<!DOCTYPE html><html><head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="This is the 2nd post description">
  <meta name="keywords" content="tag2, tag3">
  <meta name="author" content="Valentin Padurean (Ogg)">
  <title>Second Post Title</title>
  <link rel="stylesheet" href="/highlight/styles/atom-one-light.css">
  <link rel="stylesheet" href="/main.css">
</head>
<body>
  <header><a href="/"><h1><span class="markdista-logotype">λλ</span><span class="markedista-logotext"></span>arkedista Blog</h1></a></header>
  <article class="full-post">
    <header class="post-header">
      <h2 id="post-title" class="post-title">Second Post Title</h2>
      <time id="post-date" class="post-date" datetime="2018-05-16T09:23:06.000Z">&nbsp;</time>
    </header>
    <section id="post-body" class="post-body"><h1 id="gfm-example">GFM-Example</h1>
<p>GitHub Flavored Markdown Example</p>
<h2 id="index">Index</h2>
<ul>
<li>source</li>
</ul>
<pre><code> This is head1
 =============

 This is head 2
 --------------</code></pre><ul>
<li>result</li>
</ul>
<h1 id="this-is-head1">This is head1</h1>
<h2 id="this-is-head-2">This is head 2</h2>
<h2 id="table-php-markdown-style-">table (PHP-Markdown style)</h2>
<ul>
<li>source</li>
</ul>
<pre><code>First Header  | Second Header
------------- | -------------
Content Cell  | Content Cell
Content Cell  | Content Cell</code></pre><ul>
<li>result</li>
</ul>
<table>
<thead>
<tr>
<th>First Header</th>
<th>Second Header</th>
</tr>
</thead>
<tbody><tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
<tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
</tbody></table>
<ul>
<li>source</li>
</ul>
<pre><code>| Item      | Value |
| --------- | -----:|
| Computer  | $1600 |
| Phone     |   $12 |
| Pipe      |    $1 |</code></pre><ul>
<li>result</li>
</ul>
<table>
<thead>
<tr>
<th>Item</th>
<th align="right">Value</th>
</tr>
</thead>
<tbody><tr>
<td>Computer</td>
<td align="right">$1600</td>
</tr>
<tr>
<td>Phone</td>
<td align="right">$12</td>
</tr>
<tr>
<td>Pipe</td>
<td align="right">$1</td>
</tr>
</tbody></table>
<h2 id="code">code</h2>
<ul>
<li>source</li>
</ul>
<pre><code>```
this is code block
```</code></pre><ul>
<li>result</li>
</ul>
<pre><code>this is code block</code></pre><ul>
<li>source</li>
</ul>
<pre><code>```ruby
get '/' do
  "Hello world "
end
```</code></pre><ul>
<li>result</li>
</ul>
<pre><code class="language-ruby">get '/' do
  "Hello world "
end</code></pre>
<ul>
<li>other ruby example</li>
</ul>
<pre><code class="language-ruby">get '/' do
  "Hello world "
end</code></pre>
<ul>
<li>some scala example:</li>
</ul>
<pre><code class="language-scala">trait TSDBWriter
  protected implicit val scheduler: Scheduler
  protected val metrics = Metrics.openTSDBMetrics

  def config: TSDBConfig

  def publishMessages(tsDataPoints: List[TSDataPoint]): Task[Continue]

  def persistLeadershipValue(status: LeadershipStatus, now: DateTime): Task[Continue] =
    val metric = "assetEngine.leadershipState"
    val dp = TSDataPoint(
      metric = metric,
      timestamp = now.getMillis,
      value = if (status.isMaster) 1 else 0,
      tags = Map("host" -&gt; s"${status.hostname}/${status.address}")
    )

    publishMessages(List(dp))

  case class SomeCaseClass(attr1: String, attr2: Double)</code></pre>
<ul>
<li>some javascript examples:</li>
</ul>
<pre><code class="language-javascript">const fs = require('fs')
const {promisify} = require('util')
const marked = require('marked')
const frontmatter = require('yaml-front-matter')
const jsdom = require('jsdom')
const { JSDOM } = jsdom
const colors = require('colors')

colors.setTheme({
  silly: 'rainbow',
  input: 'grey',
  verbose: 'cyan',
  prompt: 'grey',
  info: 'green',
  data: 'grey',
  help: 'cyan',
  warn: 'yellow',
  debug: 'blue',
  error: 'red'
})

const toRenderDirPath = 'posts-src/to-render'
const renderedDirPath = 'posts-src/rendered'
const htmlOutputDirPath = 'posts'
const fragmentsDirPath = 'posts-src/fragments'
const postsJsonFilePath = `${htmlOutputDirPath}/posts.json`
const enc = 'utf8'
const ignoreFiles = [ '.gitkeep' ]

const readDir = promisify(fs.readdir)
const readFile = promisify(fs.readFile)
const writeFile = promisify(fs.writeFile)
const renameFile = promisify(fs.rename)

function validateMeta(meta) {
  const errors = []
  if (typeof meta.date === 'undefined' || meta.date.length === 0)
    errors.push('date')
  if (typeof meta.title === 'undefined' || meta.title.length === 0)
    errors.push('title')
  if (typeof meta.description === 'undefined' || meta.description.length === 0)
    errors.push('description')
  return errors
}

async function writePostsJson(metaFileNameToMeta) {
  console.info(`Generating ${postsJsonFilePath} ...`.info)
  metaFileNameToMeta[Symbol.iterator] = function* () {
    yield* [...this.entries()].sort((a, b) =&gt;
    new Date(b[1].date).getTime() - new Date(a[1].date).getTime())
  }
  const mdFileNameToMetaJson = JSON.stringify([...metaFileNameToMeta]/*, null, 2*/)
  await writeFile(postsJsonFilePath, mdFileNameToMetaJson)
}

function computeAndLogTotalDuration(startedAt) {
  const took = process.hrtime(startedAt)
  const tookMs = Math.round(took[1]/1000000)
  const tookStr = `${took[0]&gt;0?took[0]+'s ':''}${tookMs}ms`
  console.info(`DONE in ${tookStr}`.info)
}

const render = async () =&gt; {
  try {
    const startedAt = process.hrtime()
    const mdFileNameToMeta = new Map()
    let invalidMetaCounter = 0
    console.info(`Scanning ${toRenderDirPath} for md files to render ...`.info)
    const mdFilesNames = (await readDir(toRenderDirPath)).filter(f =&gt; ignoreFiles.indexOf(f) &lt; 0)
    if (mdFilesNames.length &gt; 0) {
      console.info(`${mdFilesNames.length} new md files found`.info)
    } else
      return console.warn('No new md files found'.warn)
    console.info(`Reading header &amp; footer from ${fragmentsDirPath} folder ...`.info)
    const headerHtml = await readFile(`${fragmentsDirPath}/header.html`, enc)
    const footerHtml = await readFile(`${fragmentsDirPath}/footer.html`, enc)
    const documentDom = new JSDOM(headerHtml+footerHtml)
    let { document } = documentDom.window
    const postTitleElem = document.querySelector("#post-title")
    const postDateElem = document.querySelector('#post-date')
    const postBodyElem = document.querySelector('#post-body')
    mdFilesNames.forEach(async mdFileName =&gt; {
      try {
        console.info(`${mdFileName} - Reading file ...`.info)
        const mdFilePath = `${toRenderDirPath}/${mdFileName}`
        const mdContentAndMeta = await readFile(mdFilePath, enc)
        console.info(`${mdFileName} - Parsing frontmatter ...`.info)
        const meta = frontmatter.loadFront(mdContentAndMeta)
        const metaErrors = validateMeta(meta)
        if (metaErrors.length &gt; 0) {
          invalidMetaCounter++
          const metaErrorsStr = metaErrors.join(', ')
          return console.error(
            `${mdFileName} - Skipped - misses frontmatter: ${metaErrorsStr}`.error)
        }
        console.info(`${mdFileName} - Rendering to HTML ...`.info)
        const mdContent = meta.__content
        const renderedHtml = marked(mdContent)
        console.info(`${mdFileName} - Injecting metadata and aggregating HTML ...`.info)
        const {date, title, description} = {...meta}
        postTitleElem.textContent = title
        // NOTE: date elem textContent will be written on client side
        if (typeof date === 'string') { // when frontmatter is JSON
          postDateElem.setAttribute('datetime', date)
          // postDateElem.textContent = new Date(date).toLocaleString()
        } else /*if (typeof date === 'object')*/ { // when frontmatter is YAML
          postDateElem.setAttribute('datetime', date.toISOString())
          // postDateElem.textContent = date.toLocaleString()
        }
        postBodyElem.innerHTML = renderedHtml
        const htmlContent = documentDom.serialize()
        const lastIndexOfDot = mdFileName.lastIndexOf('.')
        const htmlFileName = mdFileName.substr(0, lastIndexOfDot)+'.html'
        const htmlFilePath = `${htmlOutputDirPath}/${htmlFileName}`
        console.info(`${mdFileName} - Writing to ${htmlFilePath} ...`.info)
        await writeFile(htmlFilePath, htmlContent)
        const renderedMdFilePath = `${renderedDirPath}/${mdFileName}`
        console.info(`${mdFileName} - Moving to ${renderedDirPath} ...`.info)
        await renameFile(mdFilePath, renderedMdFilePath)
        mdFileNameToMeta.set(mdFileName, {
          date: date,
          title: title,
          description: description,
          htmlFileName: htmlFileName
        })
        if (mdFileNameToMeta.size + invalidMetaCounter === mdFilesNames.length) {
          console.info(`Scanning ${renderedDirPath} for previously rendered md files ...`.info)
          const mdFilesNamesRendered = (await readDir(renderedDirPath)).filter(f =&gt; {
            return ignoreFiles.indexOf(f) &lt; 0 &amp;&amp; !mdFileNameToMeta.has(f)
          })
          if (mdFilesNamesRendered.length &gt; 0) {
            console.info(`${mdFilesNamesRendered.length} previously rendered md files found`.info)
            mdFilesNamesRendered.forEach(async mdFileNameRendered =&gt; {
              try {
                const mdFilePathRendered = `${renderedDirPath}/${mdFileNameRendered}`
                const mdMeta = await readFile(mdFilePathRendered, enc)
                console.info(`${mdFileNameRendered} - Parsing frontmatter from rendered file ...`.info)
                const metaParsed = frontmatter.loadFront(mdMeta)
                const metaParsedErrors = validateMeta(metaParsed)
                if (metaParsedErrors.length &gt; 0) {
                  invalidMetaCounter++
                  const metaParsedErrorsStr = metaParsedErrors.join(', ')
                  return console.error(
                    `${mdFileNameRendered} - Skipped - misses frontmatter: ${metaParsedErrorsStr}`.error)
                }
                const lastIndexOfDotParsed = mdFileNameRendered.lastIndexOf('.')
                const htmlFileNameParsed = mdFileNameRendered.substr(0, lastIndexOfDotParsed)+'.html'
                mdFileNameToMeta.set(mdFileNameRendered, {
                  date: metaParsed.date,
                  title: metaParsed.title,
                  description: metaParsed.description,
                  htmlFileName: htmlFileNameParsed
                })
                if (mdFileNameToMeta.size + invalidMetaCounter === mdFilesNames.length + mdFilesNamesRendered.length) {
                  await writePostsJson(mdFileNameToMeta)
                  computeAndLogTotalDuration(startedAt)
                }
              } catch (e) {
                console.error(`${mdFileNameRendered} - FAILED to read (for frontmatter only)!\t${e}`.error)
              }
            })
          } else {
            console.warn(
              `No rendered md files found =&gt; ${postsJsonFilePath} content will probably `.warn +
              `be incomplete (unless there were no previously rendered files before this run)`.warn)
            await writePostsJson(mdFileNameToMeta)
            computeAndLogTotalDuration(startedAt)
          }
        }
      } catch (e) {
        console.error(`${mdFileName} FAILED!\t${e}`.error)
      }
    })
  } catch (e) {
    console.error(`FAILED!\t${e}`.error)
  }
}
render()</code></pre>
<h2 id="autolink">autolink</h2>
<ul>
<li>source</li>
</ul>
<pre><code>http://mukaer.com</code></pre><ul>
<li>result</li>
</ul>
<p><a href="http://mukaer.com">http://mukaer.com</a></p>
<h2 id="strikethrough">strikethrough</h2>
<ul>
<li>source</li>
</ul>
<pre><code>this is ~~good~~ bad</code></pre><ul>
<li>result</li>
</ul>
<p>this is <del>good</del> bad</p>
<h2 id="task-lists">Task Lists</h2>
<ul>
<li>source</li>
</ul>
<pre><code>- [x] @mentions, #refs, [links](), **formatting**, and &lt;del&gt;tags&lt;/del&gt; supported
- [x] list syntax required (any unordered or ordered list supported)
- [x] this is a complete item
- [ ] this is an incomplete item</code></pre><ul>
<li><p>result</p>
</li>
<li><p>@mentions, #refs, <a href="">links</a>, <strong>formatting</strong>, and <del>tags</del> supported</p>
</li>
<li><input checked="" disabled="" type="checkbox"> list syntax required (any unordered or ordered list supported)</li>
<li><input checked="" disabled="" type="checkbox"> this is a complete item</li>
<li><input disabled="" type="checkbox"> this is an incomplete item</li>
</ul>
<h2 id="superscript">superscript</h2>
<ul>
<li>source</li>
</ul>
<pre><code>this is the 2^(nd) time</code></pre><ul>
<li>result</li>
</ul>
<p>this is the 2^(nd) time</p>
<h2 id="underline">underline</h2>
<ul>
<li>source</li>
</ul>
<pre><code>This is _underlined_ but this is still *italic*</code></pre><ul>
<li>result</li>
</ul>
<p>This is <em>underlined</em> but this is still <em>italic</em></p>
<h2 id="highlight">highlight</h2>
<ul>
<li>source</li>
</ul>
<pre><code>This is ==highlighted==</code></pre><ul>
<li>result</li>
</ul>
<p>This is ==highlighted==</p>
</section>
  </article>
  <section id="tags-section" class="tags-section">
    <span>Tags:</span>
    <div id="tags-container" class="tags-container">
<a href="/?tag=tag2">tag2</a> |
<a href="/?tag=tag3">tag3</a>
</div>
  </section>
  <section id="page-nav" class="page-nav">
    <a id="btn-older-post" class="btn disabled" href="#"><span class="btn-arrow-icon">«</span> Older</a>
    <a id="btn-newer-post" class="btn disabled" href="#">Newer <span class="btn-arrow-icon">»</span></a>
  </section>
  <footer>
    <span id="year-placeholder">2018</span> made with
    <a href="https://github.com/padurean/markedista">
      <span class="markdista-logotype">λλ</span><span class="markedista-logotext">arkedista</span>
    </a>
  </footer>

<script type="text/javascript" src="https://code.jquery.com/jquery-3.3.1.min.js"></script>
<script type="text/javascript" src="/highlight/highlight.pack.js"></script>
<script type="text/javascript" src="/highlight/highlightjs-line-numbers.2.3.0.min.js"></script>
<script type="text/javascript" src="/main-post.js"></script>
</body></html>